package web

import (
	"fmt"
	"net/http"
	"strconv"

	"tingly-box/internal/auth"
	"tingly-box/internal/config"
	"tingly-box/internal/memory"

	"github.com/gin-gonic/gin"
)

// WebServer provides a simple web interface for configuration management
type WebServer struct {
	config     *config.AppConfig
	logger     *memory.MemoryLogger
	serverAddr string
	router     *gin.Engine
}

// ProviderForm represents provider form data
type ProviderForm struct {
	Name    string `form:"name" binding:"required"`
	APIBase string `form:"api_base" binding:"required"`
	Token   string `form:"token" binding:"required"`
}

// NewWebServer creates a new web server
func NewWebServer(appConfig *config.AppConfig, logger *memory.MemoryLogger, serverAddr string) *WebServer {
	gin.SetMode(gin.ReleaseMode)

	ws := &WebServer{
		config:     appConfig,
		logger:     logger,
		serverAddr: serverAddr,
		router:     gin.New(),
	}

	ws.setupRoutes()
	return ws
}

// setupRoutes configures web server routes
func (ws *WebServer) setupRoutes() {
	// Middleware
	ws.router.Use(gin.Logger())
	ws.router.Use(gin.Recovery())

	// Static files and templates
	ws.router.LoadHTMLGlob("web/templates/*")
	ws.router.Static("/static", "./web/static")

	// Dashboard endpoints
	ws.router.GET("/", ws.dashboard)
	ws.router.GET("/dashboard", ws.dashboard)

	// UI page routes
	ui := ws.router.Group("/ui")
	{
		ui.GET("/", ws.dashboard)
		ui.GET("/dashboard", ws.dashboard)
		ui.GET("/providers", ws.providersPage)
		ui.GET("/server", ws.serverPage)
		ui.GET("/history", ws.historyPage)
	}

	// Web UI API routes (these are handled by the web UI server itself)
	uiAPI := ws.router.Group("/ui/api")
	{
		uiAPI.GET("/providers", ws.getProviders)
		uiAPI.POST("/providers", ws.addProvider)
		uiAPI.DELETE("/providers/:name", ws.deleteProvider)
		uiAPI.GET("/status", ws.getStatus)
		uiAPI.POST("/server/start", ws.startServer)
		uiAPI.POST("/server/stop", ws.stopServer)
		uiAPI.POST("/server/restart", ws.restartServer)
		uiAPI.GET("/token", ws.generateToken)
		uiAPI.GET("/history", ws.getHistory)

		// New API endpoints for defaults and provider models
		uiAPI.GET("/defaults", ws.getDefaults)
		uiAPI.POST("/defaults", ws.setDefaults)
		uiAPI.GET("/provider-models", ws.getProviderModels)
		uiAPI.POST("/provider-models/:name", ws.fetchProviderModels)
	}
}

// getRouter returns the gin router
func (ws *WebServer) GetRouter() *gin.Engine {
	return ws.router
}

// API Handlers
func (ws *WebServer) getProviders(c *gin.Context) {
	providers := ws.config.ListProviders()
	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data":    providers,
	})
}

func (ws *WebServer) addProvider(c *gin.Context) {
	var form ProviderForm
	if err := c.ShouldBindJSON(&form); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	if err := ws.config.AddProvider(form.Name, form.APIBase, form.Token); err != nil {
		if ws.logger != nil {
			ws.logger.LogAction(memory.ActionAddProvider, map[string]interface{}{
				"name":     form.Name,
				"api_base": form.APIBase,
			}, false, err.Error())
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	if ws.logger != nil {
		ws.logger.LogAction(memory.ActionAddProvider, map[string]interface{}{
			"name":     form.Name,
			"api_base": form.APIBase,
		}, true, "Provider added successfully via web interface")
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "Provider added successfully",
	})
}

func (ws *WebServer) deleteProvider(c *gin.Context) {
	name := c.Param("name")
	if err := ws.config.DeleteProvider(name); err != nil {
		if ws.logger != nil {
			ws.logger.LogAction(memory.ActionDeleteProvider, map[string]interface{}{
				"name": name,
			}, false, err.Error())
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	if ws.logger != nil {
		ws.logger.LogAction(memory.ActionDeleteProvider, map[string]interface{}{
			"name": name,
		}, true, "Provider deleted successfully via web interface")
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "Provider deleted successfully",
	})
}

func (ws *WebServer) getStatus(c *gin.Context) {
	providers := ws.config.ListProviders()
	enabledCount := 0
	for _, provider := range providers {
		if provider.Enabled {
			enabledCount++
		}
	}

	status := gin.H{
		"server_running":    false,
		"port":              ws.config.GetServerPort(),
		"providers_total":   len(providers),
		"providers_enabled": enabledCount,
	}

	// Add memory logger status if available
	if ws.logger != nil {
		currentStatus := ws.logger.GetCurrentStatus()
		status["last_updated"] = currentStatus.Timestamp.Format("2006-01-02 15:04:05")
		if currentStatus.Running {
			status["server_running"] = true
			status["uptime"] = currentStatus.Uptime
			status["request_count"] = currentStatus.RequestCount
		}

		stats := ws.logger.GetActionStats()
		status["action_stats"] = stats
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data":    status,
	})
}

func (ws *WebServer) startServer(c *gin.Context) {
	var req struct {
		Port int `json:"port"`
	}

	c.ShouldBindJSON(&req)
	if req.Port == 0 {
		req.Port = ws.config.GetServerPort()
	}

	// In a real implementation, this would start the actual server
	// For now, we just update the status in memory
	if ws.logger != nil {
		ws.logger.UpdateServerStatus(true, req.Port, "0s", 0)
		ws.logger.LogAction(memory.ActionStartServer, map[string]interface{}{
			"port": req.Port,
		}, true, "Server started via web interface")
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": fmt.Sprintf("Server started on port %d", req.Port),
	})
}

func (ws *WebServer) stopServer(c *gin.Context) {
	// In a real implementation, this would stop the actual server
	if ws.logger != nil {
		ws.logger.UpdateServerStatus(false, 0, "", 0)
		ws.logger.LogAction(memory.ActionStopServer, nil, true, "Server stopped via web interface")
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "Server stopped successfully",
	})
}

func (ws *WebServer) restartServer(c *gin.Context) {
	var req struct {
		Port int `json:"port"`
	}

	c.ShouldBindJSON(&req)
	if req.Port == 0 {
		req.Port = ws.config.GetServerPort()
	}

	// In a real implementation, this would restart the actual server
	if ws.logger != nil {
		ws.logger.UpdateServerStatus(true, req.Port, "0s", 0)
		ws.logger.LogAction(memory.ActionRestartServer, map[string]interface{}{
			"port": req.Port,
		}, true, "Server restarted via web interface")
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": fmt.Sprintf("Server restarted on port %d", req.Port),
	})
}

func (ws *WebServer) generateToken(c *gin.Context) {
	clientID := c.DefaultQuery("client_id", "web")
	jwtManager := auth.NewJWTManager(ws.config.GetJWTSecret())
	token, err := jwtManager.GenerateToken(clientID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	if ws.logger != nil {
		ws.logger.LogAction(memory.ActionGenerateToken, map[string]interface{}{
			"client_id": clientID,
		}, true, "Token generated via web interface")
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data": gin.H{
			"token":     token,
			"client_id": clientID,
		},
	})
}

func (ws *WebServer) getHistory(c *gin.Context) {
	limitStr := c.DefaultQuery("limit", "20")
	limit, _ := strconv.Atoi(limitStr)

	var history []memory.HistoryEntry
	if ws.logger != nil {
		history = ws.logger.GetHistory(limit)
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data":    history,
	})
}

// Page Handlers
func (ws *WebServer) dashboard(c *gin.Context) {
	c.HTML(http.StatusOK, "dashboard.html", gin.H{
		"title":      "Tingly Box Dashboard",
		"serverAddr": ws.serverAddr,
	})
}

func (ws *WebServer) providersPage(c *gin.Context) {
	c.HTML(http.StatusOK, "providers.html", gin.H{
		"title": "Providers - Tingly Box",
	})
}

func (ws *WebServer) serverPage(c *gin.Context) {
	c.HTML(http.StatusOK, "server.html", gin.H{
		"title": "Server - Tingly Box",
	})
}

func (ws *WebServer) historyPage(c *gin.Context) {
	c.HTML(http.StatusOK, "history.html", gin.H{
		"title": "History - Tingly Box",
	})
}

// getDefaults returns the current global defaults
func (ws *WebServer) getDefaults(c *gin.Context) {
	globalConfig := ws.config.GetGlobalConfig()
	if globalConfig == nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "Global config not available",
		})
		return
	}

	defaultProvider, defaultModel, defaultModelName := globalConfig.GetDefaults()
	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data": gin.H{
			"default_provider":   defaultProvider,
			"default_model":      defaultModel,
			"default_model_name": defaultModelName,
		},
	})
}

// setDefaults updates the global defaults
func (ws *WebServer) setDefaults(c *gin.Context) {
	var req struct {
		DefaultProvider  string `json:"default_provider"`
		DefaultModel     string `json:"default_model"`
		DefaultModelName string `json:"default_model_name"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	globalConfig := ws.config.GetGlobalConfig()
	if globalConfig == nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "Global config not available",
		})
		return
	}

	// Update defaults
	if req.DefaultProvider != "" {
		if err := globalConfig.SetDefaultProvider(req.DefaultProvider); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"success": false,
				"error":   err.Error(),
			})
			return
		}
	}

	if req.DefaultModel != "" {
		if err := globalConfig.SetDefaultModel(req.DefaultModel); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"success": false,
				"error":   err.Error(),
			})
			return
		}
	}

	if req.DefaultModelName != "" {
		if err := globalConfig.SetDefaultModelName(req.DefaultModelName); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"success": false,
				"error":   err.Error(),
			})
			return
		}
	}

	if ws.logger != nil {
		ws.logger.LogAction(memory.ActionUpdateDefaults, map[string]interface{}{
			"default_provider":   req.DefaultProvider,
			"default_model":      req.DefaultModel,
			"default_model_name": req.DefaultModelName,
		}, true, "Global defaults updated via web interface")
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "Defaults updated successfully",
	})
}

// getProviderModels returns provider models information
func (ws *WebServer) getProviderModels(c *gin.Context) {
	providerModelManager := ws.config.GetProviderModelManager()
	if providerModelManager == nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "Provider model manager not available",
		})
		return
	}

	providers := providerModelManager.GetAllProviders()
	providerModels := make(map[string]interface{})

	for _, providerName := range providers {
		models := providerModelManager.GetModels(providerName)
		apiBase, lastUpdated, _ := providerModelManager.GetProviderInfo(providerName)

		providerModels[providerName] = map[string]interface{}{
			"models":       models,
			"api_base":     apiBase,
			"last_updated": lastUpdated,
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data":    providerModels,
	})
}

// fetchProviderModels fetches models for a specific provider
func (ws *WebServer) fetchProviderModels(c *gin.Context) {
	providerName := c.Param("name")

	if providerName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"error":   "Provider name is required",
		})
		return
	}

	// Fetch and save models
	err := ws.config.FetchAndSaveProviderModels(providerName)
	if err != nil {
		if ws.logger != nil {
			ws.logger.LogAction(memory.ActionFetchModels, map[string]interface{}{
				"provider": providerName,
			}, false, err.Error())
		}

		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	// Get the updated models
	providerModelManager := ws.config.GetProviderModelManager()
	models := providerModelManager.GetModels(providerName)

	if ws.logger != nil {
		ws.logger.LogAction(memory.ActionFetchModels, map[string]interface{}{
			"provider":     providerName,
			"models_count": len(models),
		}, true, fmt.Sprintf("Successfully fetched %d models for provider %s", len(models), providerName))
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": fmt.Sprintf("Successfully fetched %d models for provider %s", len(models), providerName),
		"data":    models,
	})
}
